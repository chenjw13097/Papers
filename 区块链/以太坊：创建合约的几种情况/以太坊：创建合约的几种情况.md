# 以太坊：创建合约的几种情况

**欢迎转载，但须指明出处：**[https://github.com/chenjw13097/papers](https://github.com/chenjw13097/papers/blob/master/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/%E4%BB%A5%E5%A4%AA%E5%9D%8A%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5.md)    

### 创建未定义构造方法的合约

未定义构造方法的合约默认含一个无payable修饰的构造方法。  

#### 部署成功情况

编写源码：  
```
pragma solidity ^0.4.12;

contract DataStorage {
    uint256 data;

    function set(uint256 x) public {
        data = x;
    }

    function get() public constant returns (uint256 retVal) {
        return data;
    }
}
```
  
字节码：  
608060405234801561001057600080fd  
5b5060df8061001f6000396000f300  
6080604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b114604e5780636d4ce63c146078575b600080fd5b348015605957600080fd5b5060766004803603810190808035906020019092919050505060a0565b005b348015608357600080fd5b50608a60aa565b6040518082815260200191505060405180910390f35b8060008190555050565b600080549050905600a165627a7a72305820879b17325bbf18ab328711a82852468ddfbb5ef91bb8ab27ff16546b16217d380029  
  
汇编代码：  
PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT  
JUMPDEST POP PUSH1 0xDF DUP1 PUSH2 0x1F PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP  
PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x49 JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x60FE47B1 EQ PUSH1 0x4E JUMPI DUP1 PUSH4 0x6D4CE63C EQ PUSH1 0x78 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH1 0x59 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x76 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH1 0xA0 JUMP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH1 0x83 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x8A PUSH1 0xAA JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST DUP1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD SWAP1 POP SWAP1 JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 DUP8 SWAP12 OR ORIGIN JUMPDEST 0xbf XOR 0xab ORIGIN DUP8 GT 0xa8 0x28 MSTORE 0x46 DUP14 0xdf 0xbb 0x5e 0xf9 SHL 0xb8 0xab 0x27 SELFDESTRUCT AND SLOAD PUSH12 0x16217D380029000000000000  
  
代码执行过程分析：  
构造方法是默认的。因为无payable修饰，所以转账额需要设置为0，才能部署成功。当转账额设置为0时，先将存储部分（黄色背景部分）暂存到内存，然后从内存再设置到执行结果的Return中。  

#### 部署失败情况

返回空字节放入到执行结果的Return中，设置结果为REVERT，表示条件检验不过。  

#### 乱写代码的情况

此时仍旧是按正常的处理流程，可能正常的退出，可能是REVERT，可能是异常（合约执行逻辑）。这时执行结果的Return没有被设置。  
这是可以理解的，因为Solidity源码的逻辑本身不是执行平台能够控制的。  
以太坊要求执行代码消耗Gas，所以作恶者也是要付出代价的，毕竟这个要占用网络的存储资源。  

#### 代码为空的情况

是否允许为空，可以由业务决定。  

### 创建含无payable修改的含参构造方法的合约

源码：  
```
pragma solidity ^0.4.12;

contract DataStorage {
    uint256 data;

    constructor(uint256 x) public {
        data = x;
    }

    function set(uint256 x) public {
        data = x;
    }

    function get() public constant returns (uint256 retVal) {
        return data;
    }
}
```
  
字节码：  
608060405234801561001057600080fd  
5b5060405160208061012883398101806040528101908080519060200190929190505050806000819055505060df806100496000396000f300  
6080604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b114604e5780636d4ce63c146078575b600080fd5b348015605957600080fd5b5060766004803603810190808035906020019092919050505060a0565b005b348015608357600080fd5b50608a60aa565b6040518082815260200191505060405180910390f35b8060008190555050565b600080549050905600a165627a7a72305820ae881b096783230f034d45fa950fdeab31f10a90e88ae75ae37c5c54a5ab89520029  
  
汇编代码：  
PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT  
JUMPDEST POP PUSH1 0x40 MLOAD PUSH1 0x20 DUP1 PUSH2 0x128 DUP4 CODECOPY DUP2 ADD DUP1 PUSH1 0x40 MSTORE DUP2 ADD SWAP1 DUP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP DUP1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP POP PUSH1 0xDF DUP1 PUSH2 0x49 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP  
PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x49 JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x60FE47B1 EQ PUSH1 0x4E JUMPI DUP1 PUSH4 0x6D4CE63C EQ PUSH1 0x78 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH1 0x59 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x76 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH1 0xA0 JUMP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH1 0x83 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x8A PUSH1 0xAA JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST DUP1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD SWAP1 POP SWAP1 JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 0xae DUP9 SHL MULMOD PUSH8 0x83230F034D45FA95 0xf 0xde 0xab BALANCE CALL EXP SWAP1 0xe8 DUP11 0xe7 GAS 0xe3 PUSH29 0x5C54A5AB89520029000000000000000000000000000000000000000000  
  
过程分析：  
从字节码末尾加载参数并暂存到内存，然后又读出，存储到DB，Key是字段编号，从0开始。然后将部署部分设置到执行结果的Return中。  

### 附：合约执行过程和结果解析

过程分析：  
如果data小于4字节，则返回程序结果Return为空，并置为REVERT。  
加载data，取出前4字节，与合约的所有方法的4字节码编码对比，匹配上则跳转到指定方法的入口并执行。然后执行，如果有返回值，则得到后放到程序结果的Return中。  
  
Abi.Function的decodeResult方法就可以解析返回的Return数据，得到的是List<?>。  
